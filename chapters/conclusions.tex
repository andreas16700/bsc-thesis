\chapter{Conclusion}
\label{chap:conclusion}
In concluding, it is evident that Swift holds substantial potential as a serverless language, albeit with several areas necessitating further development and exploration.

Swift's expressiveness and simplicity render it a productive choice for developers, offering a unique blend of performance and usability. However, a more comprehensive practical comparison with other serverless languages such as Python, JavaScript, or Go is imperative to fully comprehend its strengths and weaknesses in realistic serverless scenarios. This will not only validate Swift's theoretical advantages but also provide valuable insights for its future development.

One important aspect to consider, is that the decision to utilize serverless architecture should not be made lightly. While serverless computing offers scalability and reduces the need for server management, in some cases, a shift from a serverless to a monolithic architecture may lead to improved scalability, resilience, and cost-effectiveness, as was the case with the Prime Video service~\cite{primevideo2023}. This underscores the significance of a case-by-case analysis when deciding on the architectural choice, which is a subject of ongoing debate in the tech industry~\cite{virtualizationreview2023}.

The current state of Swift as a serverless language is promising, but there are limitations that need to be addressed. One of the key challenges is the lack of helpful feedback for some errors, which contradicts Swift's core promise of safety. Developers often find themselves needing to use \texttt{lldb} on remote machines to troubleshoot, which can be a significant hurdle in the development process.

Moreover, the need for better documentation and Linux support is evident. The absence of a built-in mechanism to ensure that all APIs used are supported on the Linux platform is a significant drawback. Developers are currently left to rely on Docker tests or discover at runtime if a feature is unsupported. Enhancing Linux support and providing comprehensive documentation would greatly improve Swift's fitness as a systems language and its viability as a serverless language.

In the context of OpenWhisk's ActionLoop proxy, the importance of intra-concurrency cannot be overstated. The case study results indicate that the lack of real concurrency wastes much of the hardware's potential and provides poor scaling, which is contrary to the essence of serverless. As most runtimes use the ActionLoop proxy, its support of concurrency is critically important for the efficient use of Swift in serverless settings.

Looking ahead, the future of Swift as a serverless language is bright, but it hinges on addressing these challenges and capitalizing on its strengths. The journey of Swift in the serverless landscape is just beginning, and with the right improvements, it can become a powerful tool in the hands of developers. In this journey, it is vital to remember that while serverless architecture offers many benefits, the decision between serverless and monolithic architectures should be made with careful consideration ofthe specific context and requirements of the project, as well illustrated by the case of Amazon's Prime Video service